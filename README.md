# *Пример можете посмотреть [здесь](https://github.com/PronikFire/Client-Max-Api).*

# Гайд на API MAX

## Общая информация

У Max существует два API:

* **WSS (WebSocket)** - для web-версии
* **TLS** - для приложений

По факту это один и тот же API, но разница между ними все же есть. Как пример, в web-версии вырезали аутентификацию по телефону.

---

## Web API

Наиболее простой API с понятной структурой и самым легким способом анализа.

### Как анализировать

Анализ можно проводить прямо в браузере с помощью панели разработчика:

1. Зайти на сайт: [https://web.max.ru](https://web.max.ru)
2. Открыть консоль разработчика:

   * `Ctrl + Shift + J`, либо
   * ПКМ -> **Проверить**
3. Перейти во вкладку **Network**.
4. (Опционально) В фильтрах сверху выбрать **Socket**.
5. Перезагрузить страницу.
6. Найти и открыть WebSocket-подключение:

   * если выполнен пункт 4 - оно будет первым и единственным.
7. Перейти во вкладку **Messages**.

### Содержание сообщений

Пример:

> {"ver":11,"cmd":0,"seq":0,"opcode":6,"payload":{*здесь payload*}}

| Поля    | Описание                                                                                                                                       |
| ------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| ver     | Версия (протокола?). За все время анализа не менялась.                                                                                         |
| cmd     | Тип команды (см. [здесь](#значения-cmd)).                                                                                                  |
| seq     | Номер пакета. Обычно начинается с 1 и увеличивается на 1 с каждым отправленным пакетом. Ответ на пакет (если он есть) приходит с таким же seq. |
| opcode  | Тип пакета (см. [здесь](#Список-opcode)).                                                                                                   |
| payload | Полезная нагрузка - содержание пакета.                                                                                                         |

Сообщения кодируются в JSON.

---

## App API

Здесь начинается самое интересное. В отличие от web-версии, в приложении нет простого пути анализа, а структура пакетов другая.

Далее описание ориентировано на **Windows-версию**.

### Как анализировать

1. Скачать Windows-версию приложения:

   * [https://download.max.ru/#desktop](https://download.max.ru/#desktop)
2. Установить приложение.

   * Я использовал виртуальную машину, но это не принципиально.
3. Подготовить инструмент для анализа трафика.

   * В данном описании используется **mitmproxy**.

### Установка mitmproxy

1. Скачать Windows-версию:

   * [https://www.mitmproxy.org](https://www.mitmproxy.org)
2. Установить приложение.
3. Запустить **mitmweb** (веб-интерфейс - более удобен).

### Установка сертификата

Файл сертификата:

```
C:\Users\%User%\.mitmproxy\mitmproxy-ca-cert.cer
```

Параметры установки:

* Устанавливать для: **Локального компьютера**
* Хранилище: **Доверенные корневые центры сертификации**

### Настройка mitmproxy

В интерфейсе mitmproxy:

1. Перейти во вкладку **Capture**.
2. Включить **Local Applications**.
3. Выбрать `max.exe`.
4. Перейти во вкладку **Flow List**.
5. Очистить список:

   * **File -> Clear All**
6. (Опционально) Перезапустить Max.

Готово.

### Советы по анализу сообщений

В mitmproxy после выбора соединения в правом верхнем углу можно выбрать режим **View**.

Наиболее полезные режимы:

* **Hex Dump**
* **Hex Stream**

Для анализа **Hex Stream** удобно использовать сервис:

* [https://hexed.it](https://hexed.it) - отличный инструмент для работы с бинарными данными.

---

### Содержание сообщений

Заголовок - 10 байт.

| Байты | Описание               |
| ----- | ---------------------- |
| 1     | ver                    |
| 2     | cmd                    |
| 3..4  | seq                    |
| 5..6  | opcode                 |
| 7     | ???                    |
| 8..10 | Длина payload в байтах |
| 11..  | Payload                |

Payload кодируется в формате **MsgPack**.

> [!IMPORTANT]
> Если значение 7-го байта ≠ 0, то в начале payload до MsgPack присутствуют 2 дополнительных неизвестных байта.

---

## Значения `cmd`

> [!NOTE]
> Актуально и для WebSocket

| Значение | Описание                                     |
| -------- | -------------------------------------------- |
| 0        | Запрос                                       |
| 1        | Ответ                                        |
| 2        | ??? (видел, но не уверен, какую роль играет) |
| 3        | Ошибка                                       |

---

## Список `opcode`

> `(w)` - предположение на основе web-версии

| Opcode | Описание                                                |
| ------ | ------------------------------------------------------- |
| 1      | Interactive? Наверное, что-то вроде пинга.              |
| 5      | События - действия клиента (w)                          |
| 6      | Информация о клиенте                                    |
| 11     | Отправка номера телефона (аутентификация)               |
| 12     | Проверка кода из SMS                                    |
| 16     | Задать профиль (w)                                      |
| 19     | Вход по токену                                          |
| 22     | Задать настройку (w)                                    |
| 25     | Получить аватарки (w)                                   |
| 26     | Секции по ID (w)                                        |
| 27     | Эмодзи (w)                                              |
| 28     | Эмодзи по ID (w)                                        |
| 32     | Контакт по ID (w)                                       |
| 35     | Последнее время онлайн контакта по ID (w)               |
| 36     | Список заблокированных контактов (w)                    |
| 48     | Информация о чате по ID (w)                             |
| 49     | История чата по ID (w)                                  |
| 50     | Действие с каналом (например, отметить прочитанным) (w) |
| 64     | Отправить сообщения (w)                                 |
| 73     | Поиск по чату (w)                                       |
| 75     | Подписка на чат (клиент просматривает чат) (w)          |
| 76     | Создать групповой звонок (w)                            |
| 79     | Истории (w)                                             |
| 83     | Получить видео по ID (w)                                |
| 89     | Информация о ссылке (w)                                 |
| 96     | Сессии клиента (входы, устройства и т.п.) (w)           |
| 130    | Событие, связанное с чатом (от сервера) (w)             |
| 160    | Получить мини-приложение (w)                            |
| 177    | ??? (w)                                                 |
| 178    | Добавить реакцию на сообщение (w)                       |
| 180    | Реакции на сообщениях (w)                               |
| 272    | Папки (w)                                               |
| 274    | Добавить папку (w)                                      |
| 275    | Задать порядок папок (w)                                |
| 276    | Удалить папку (w)                                       |
| 288    | Запрос QR-кода для входа (w)                            |
| 289    | Статус QR-кода по trackId (w)                           |
| 291    | Вход по trackId после сканирования QR-кода (w)          |
| 292    | Запрос от сервера: показать баннер                      |

---

## Проблема 7-го байта

Пару матов про 7-й байт.

Желание сделать API у меня было давно, но я так его и не реализовал. Основная причина - 7-й байт заголовка.

### Суть проблемы

Если значение 7-го байта не равно нулю, то в начале payload появляются 2 неизвестных байта, и payload перестает адекватно декодироваться как MsgPack.
Я не имею ни малейшего понятия, что это за байт и в чем его смысл.
Пробовал использовать нейросети для анализа пакетов - но они слишком тупые для таких задач.
Единственный реальный способ разобраться - декомпиляция приложения, но я все же хочу еще увидеть солнце, так что этим заниматься не собираюсь.

На данный момент у меня есть лишь два предположения:

1. Это некий вид сжатия.
2. Это некое шифрование.

Скорее всего, оба предположения неверны, потому что в случае сжатия 7-й байт встречается даже в маленьких пакетах, где сжатие бессмысленно, а в больших пакетах его может не быть. А в случае шифрования пакет все еще частично читаем и частично декодируется как MsgPack.

Выглядит это так, будто payload просто побит.
